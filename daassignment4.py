# -*- coding: utf-8 -*-
"""DAassignment4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u252HAyPsrU67iJxP0-XNrWc87joM_3G
"""

import numpy as np
import pandas as pd
from scipy.optimize import minimize, Bounds
import matplotlib.pyplot as plt
import os
from functools import partial

def clean_data(file_path, output_file_path):
    """
    Clean the ODI over-by-over data for the first innings and relevant metrics.

    Parameters:
        file_path (str): Path to the input CSV file or URL.
        output_file_path (str): Path to save the cleaned data CSV file.

    Returns:
        DataFrame: A cleaned pandas DataFrame with the relevant metrics.
    """

    try:
        df = pd.read_csv(file_path)

        if 'Date' in df.columns:
            df['Date'] = (df['Date'].str.replace(',', '')
                          .str.strip()
                          .pipe(partial(pd.to_datetime, errors='coerce', dayfirst=True)))

        conditions = {
            'Innings': lambda x: x == 1,
            'Error.In.Data': lambda x: x != 1,
            'Wickets.in.Hand': lambda x: x.between(1, 10)
        }
        mask = pd.DataFrame({col: conditions[col](df[col]) for col in conditions}).all(axis=1)
        df = df.loc[mask]

        derived_columns = {
            'Overs_left': lambda x: x['Total.Overs'] - x['Over'],
            'Total.Runs': lambda x: x.groupby('Match')['Runs'].cumsum(),
            'Runs_to_score': lambda x: x['Innings.Total.Runs'] - x['Total.Runs']
        }

        df = df.assign(**{col: func(df) for col, func in derived_columns.items()})

        relevant_columns = ['Match', 'Innings', 'Wickets.in.Hand', 'Runs_to_score', 'Overs_left']
        cleaned_df = df[relevant_columns].reset_index(drop=True)

        print('Cleaned data:')
        print(cleaned_df.head())

        cleaned_df.to_csv(output_file_path, index=False)

        return cleaned_df

    except pd.errors.EmptyDataError:
        raise ValueError("The file is empty.")
    except pd.errors.ParserError:
        raise ValueError("Error parsing the file. Please check the file format.")
    except Exception as e:
        raise RuntimeError(f"An error occurred while processing the data: {str(e)}")

def run_production_model(u, Z0, L): # run production model
    return Z0 * (1 - np.exp(-L * u / Z0))

def log_loss_function(params, u_data, w_data, y_data, num_wickets): # loss function (with adjusted normalization)
    Z0 = params[:num_wickets]
    L = params[num_wickets:]

    total_loss = 0
    total_points = 0

    for w in range(num_wickets):
        u_w = u_data[w_data == w]
        y_w = y_data[w_data == w]
        Z0_w = Z0[w]
        L_w = L[w]

        if len(u_w) == 0 or len(y_w) == 0:
            continue

        y_pred = run_production_model(u_w, Z0_w, L_w)

        y_pred = np.clip(y_pred, 1e-10, None)
        y_w = np.clip(y_w, 1e-10, None)


        loss = np.sum((y_pred + 1) * np.log((y_pred + 1) / (y_w + 1)) - y_pred + y_w)
        total_loss += loss
        total_points += len(y_w)

    return total_loss / total_points if total_points > 0 else np.inf  # Normalize by total points

def fit_model(u_data, w_data, y_data, num_wickets):    # Fit the model for Z0(w) and L(w)
    initial_params = np.ones(num_wickets * 2)  # Initial guesses for Z0 and L
    bounds = Bounds([0.1] * num_wickets * 2, [np.inf] * num_wickets * 2)

    result = minimize(log_loss_function, initial_params, args=(u_data, w_data, y_data, num_wickets), bounds=bounds)

    if result.success:
        fitted_params = result.x
        Z0 = fitted_params[:num_wickets]
        L = fitted_params[num_wickets:]
        return Z0, L
    else:
        raise ValueError("Optimization failed!")

def calculate_weighted_L(L, w_data):  #Calculating weighted average for L
    weights = np.array([np.sum(w_data == w) for w in range(len(L))])
    weighted_L = np.average(L, weights=weights)
    return weighted_L

def refit_Z0(u_data, w_data, y_data, common_L, num_wickets): # Refit Z0(w) using the common L
    def refit_loss(params, u_data, w_data, y_data, common_L):
        Z0 = params
        total_loss = 0
        total_points = 0

        for w in range(num_wickets):
            u_w = u_data[w_data == w]
            y_w = y_data[w_data == w]
            Z0_w = Z0[w]

            if len(u_w) == 0 or len(y_w) == 0:
                continue

            y_pred = run_production_model(u_w, Z0_w, common_L)
            y_pred = np.clip(y_pred, 1e-10, None)
            y_w = np.clip(y_w, 1e-10, None)

            loss = np.sum((y_pred + 1) * np.log((y_pred + 1) / (y_w + 1)) - y_pred + y_w)
            total_loss += loss
            total_points += len(y_w)  # Count the number of points

        return total_loss / total_points if total_points > 0 else np.inf

    initial_Z0 = np.ones(num_wickets)
    result = minimize(refit_loss, initial_Z0, args=(u_data, w_data, y_data, common_L))

    if result.success:
        final_Z0 = result.x
        return final_Z0
    else:
        raise ValueError("Refitting failed!")

def plot_run_production(Z0, L, num_wickets, u_range): #Plot for run production function
    u_values = np.linspace(0, max(u_range), 100)
    plt.figure(figsize=(10, 6))

    for w in range(num_wickets):
        y_values = run_production_model(u_values, Z0[w], L[w])
        plt.plot(u_values, y_values, label=f'Wickets = {w+1}')

    plt.xlabel('Overs to go (u)')
    plt.ylabel('Predicted Runs (Z(u, w))')
    plt.title('Run Production Functions')
    plt.legend()
    plt.show()

def report_results(Z0, L, common_L, preliminary_Z0, preliminary_L, u_data, w_data, y_data, num_wickets):
    preliminary_params = np.concatenate((preliminary_Z0, preliminary_L))  # Combine Z0 and L
    preliminary_loss = log_loss_function(preliminary_params, u_data, w_data, y_data, num_wickets)

    final_params = np.concatenate((Z0, np.full(num_wickets, common_L)))  # Combine final Z0 and common L
    final_loss = log_loss_function(final_params, u_data, w_data, y_data, num_wickets)

    print("**Plots of Run Production Functions:**")
    plot_run_production(Z0, np.full(num_wickets, common_L), num_wickets, u_data)

    print("\n**Report of Parameters:**")
    print(f"Final Z0(w): {Z0}")
    print(f"Common Slope (L): {common_L}")

    print("\n**Normalized Loss Calculation:**")
    print(f"Preliminary Normalized Loss: {preliminary_loss}")
    print(f"Final Normalized Loss: {final_loss}")

if __name__ == "__main__":
    file_path = 'https://raw.githubusercontent.com/Arjun-08/Duckworth-Lewis-Method/refs/heads/main/04_cricket_1999to2011.csv'
    output_file_path = 'cleaned_data.csv'  # Path for cleaned data output
    df = clean_data(file_path, output_file_path)

    u_data = df['Overs_left'].values
    w_data = df['Wickets.in.Hand'].values
    y_data = df['Runs_to_score'].values

    num_wickets = 10

    preliminary_Z0, preliminary_L = fit_model(u_data, w_data, y_data, num_wickets)
    print(f"Preliminary Z0(w): {preliminary_Z0}")
    print(f"Preliminary L(w): {preliminary_L}")

    common_L = calculate_weighted_L(preliminary_L, w_data)

    final_Z0 = refit_Z0(u_data, w_data, y_data, common_L, num_wickets)

    # plot_run_production(final_Z0, np.full(num_wickets, common_L), num_wickets, u_data)

    report_results(final_Z0, np.full(num_wickets, common_L), common_L, preliminary_Z0, preliminary_L, u_data, w_data, y_data, num_wickets)


    print("**Plots of Run Production Functions:**")
    plot_run_production(final_Z0, np.full(num_wickets, common_L), num_wickets, u_data)